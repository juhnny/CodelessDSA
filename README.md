# 코드 없는 알고리즘과 데이터 구조
Codeless Data Structures and Algorithms

# Part 1 데이터 구조

## 1 데이터 구조와 알고리즘, 자료형, 빅 오 표기법

### 데이터 구조와 알고리즘 개요

### 데이터 구조

### 알고리즘

### 데이터 구조와 알고리즘의 관계

### 기본 자료형

#### 불

#### 문자

#### 정수

#### 부동 소수점 수

### 함수

#### 함수, 메소드, 프로시저, 서브루틴

### 재귀와 반복

### 알고리즘의 세 가지 유형

### 알고리즘 분석

### 빅 오 표기법


## 2 선형 데이터 구조

### 컴퓨터 메모리

### 선형 데이터 구조의 개요

### 배열

### 리스트

### 스택
**스택**은 추가된 요소를 사용 가능한 메모리의 가장 앞 주소에 배치하는 선형 데이터 구조의 한 종류

삭제 시에는 마지막으로 추가된 요소를 삭제. 스택 구조를 **후입선출**last in first out, LIFO 데이터 구조라고 함.

스택에 요소를 추가하는 동작을 **푸시**push, 삭제하는 동작을 **팝**pop이라고 함. 

### 큐
**큐**queue는 각 요소에 우선순위를 부여하는 데이터 구조의 한 종류. 

큐에 요소를 추가할 맨 뒤rear에 추가되고 삭제할 때는 맨 앞front 있던 요소가 삭제된다. 큐를 **선입선출**first in first out, FIFO 구조라고 함. 

요소를 추가하는 것을 **인큐**enqueue, 삭제하는 것을 **데큐**dequeue라고 함.

### 우선순위 큐
기본적인 큐의 확장. 데이터 압축, 네트워크 등 다양한 분야에서 사용됨.

키와 값key-value을 이용해 큐의 요소들을 정렬함. 우선순위 큐를 구현할 때는 링크드 리스트나 배열 같은 데이터 구조를 사용. 

모든 요소는 우선순위가 있으며 이는 키에 해당한다.(?) 우선순위가 높은 요소는 낮은 요소보다 큐에서 먼저 삭제됨. 우선순위가 같다면 먼저 추가된 요소부터 삭제됨. 

따라서 우선순위 큐는 일반적으로 요소 추가, 요소 삭제, 우선순위 높은 요소 가져오기, 큐가 가득 찾는지 확인하기 등의 메소드를 제공. 


## 3 트리 데이터 구조

### 트리
트리 데이터 구조는 데이터를 계층으로 정렬. 트리 구조의 최상단이 **루트 노드**root node. 루트 노드에서 멀어지는 방향의 노드를 **하위 노드** 또는 **자식 노드**라고 하고, 가까워지는 방향의 노드를 **상위 노드** 또는 **부모 노드**라고 함. 가지 끝 나뭇잎에 해당하는 노드를 **말단 노드** 또는 **리프 노드**leaf node라고 함.

노드를 연결하는 선을 **에지**edge라고 함

특정 노드와 그 자식 노드들로 구성된 트리를 **하위 트리** 또는 **서브 트리**subtree라고 함. 부분집합 개념.

트리 구조에서 자식 노드는 하나의 부모 노드만 가진다. 여러 부모 노드를 갖는 구조는 **그래프**graph라고 함. 

노드에는 데이터를 저장하며 식별을 위해 키-값 형식을 사용할 수도 있다. 

트리를 탐색하는 과정을 **순회**traversal라고 함.

### 이진 트리
**이진트리**binary tree는 가장 많이 사용되는 데이터 구조. 각 부모 노드가 항상 두 개의 자식 노드와 연결되어 있다. 

이진 트리의 가장 일반적인 유형은 **이진 탐색 트리**binary search tree. 트리 구조로 정렬된 데이터를 저장하는 데 효율적.

이진 탐색 트리에서 모든 노드의 키는 왼쪽 서브트리보다 크고, 오른쪽 서브트리보다 작다. 

이진 탐색 트리로 할 수 있는 동작은 주로 세 가지.
- 트리에 노드를 추가
- 트리에서 노드를 삭제
- 노드를 선택해 탐색하고자 하는 키가 존재하는지 확인

### AVL 트리

불균형 이진 트리(가지가 한 쪽으로만 뻗어나간 모습)는 메모리 효율이 떨어짐.

트리의 균형을 조정하여 트리의 높이(계층 수)를 최소로 만들면 메모리를 더 효율적으로 사용 가능.

**AVL 이진 트리**Adelson-Velsky and Landis에서는 서브트리 2개 사이에서 높이 차이를 감지하면 **트리 회전**tree rotation이라는 균형 조정 과정을 수행. AVL 트리의 균형 조정 과정의 시간 복잡도는 O(log*n*). AVL 트리는 일부 데이터베이스 검색 시스템에서 사용됨. 

### RB 트리
**RB 이진 탐색 트리**는 AVL 이진 탐색 트리와 비슷하지만 트리 회전수가 적어 더 효율적. RB 트리의 시간 복잡도는 O(log*n*)

### B 트리
**B 트리**는 자식 노드를 3개 이상 가질 수 있음. 

데이터베이스 시스템 설계에 사용되는 데이터 구조. 많은 파일 시스템에서 데이터 계층 구조로 B 트리를 사용. 파일 시스템에는 폴더가 있고 폴더 각각에는 여러 파일이 들어있는 다른 폴더가 존재할 수 있다. 노드의 키-값 구조를 통해 폴더 각각의 이름을 파일 시스템의 객체와 연결할 수 있다. 

### 힙
**힙**heap은 이진 트리 데이터 구조의 한 종류(**힙 메모리**와는 전혀 다른 개념이므로 주의). 값이 최대 혹은 최소인 노드에 빠르게 접근해야 하는 응용 프로그램에 적합하다. 

우선순위 큐는 힙을 사용해 구현할 수 있다.

힙의 구조에는 두 가지가 있다. 
- **최대 힙**max heap : 루트 노드가 힙에서 가장 큰 값이고 노드 각각의 값이 부모 노드의 값보다 작거나 같도록 구성한 힙
- **최소 힙**min heap : 루트 노드가 힙에서 가장 작은 값이고 노드 각각의 값이 부모 노드의 값보다 크거나 같도록 구성한 힙

최소 힙이나 최대 힙을 적용한 응용 프로그램에서 이들의 성능을 대체할 수 있는 다른 데이터 구조는 없다(?).


## 4 해시 데이터 구조

### 해시와 해시 함수
**해시**는 어떤 길이의 임의 데이터를 고정 길이의 데이터(**해시값**hash value)로 매핑하는 것. 

**해시 함수**는 해시를 실행하기 위해 하나의 값을 다른 값으로 변환하는 함수. 해시 함수의 특징은 입력 데이터가 문자든 문자열이든 기호든 출력되는 값(**해시값**hash value, 일반적으로 16진수)의 길이가 항상 고정되어 있다는 것.

해시 함수는 입력 데이터의 비트 하나만 달라져도 출력되는 해시값이 완전히 달라진다. 하지만 서로 다른 입력값이 같은 해시값을 생성할 가능성도 없지 않다. 이 경우 **해시 충돌** 발생. 해시 함수가 잘 정의되어 있으면 내부 연산이 빠르고 충돌 발생이 적다. 

해시값 중복이 없는 해시함수를 만들 수 없는 건가????

### 해시 테이블
**해시 테이블**hash table은 키와 값으로 구성된 검색 시스템. 해시 테이블에는 모든 키에 대응하는 값이 있다. 해시 테이블을 이용하는 탐색을 **해싱**이라고 함.

(해시 테이블 구현 부분은 이해되지 않음)

(체이닝 소개)

### 컴퓨터 보안 기초
**컴퓨터 네트워킹**은 컴퓨터가 자원을 공유할 수 있도록 하는 컴퓨팅 분야

**스푸핑**spoofing(누군가가 다른 사람 행세를 하여 정보를 탈취하는 것) 등 정보교환을 어지럽히는 행위를 방지하기 위해 암호화를 사용

#### 암호 시스템
**암호 시스템**은 **평문**plaintext 입력을 **암호문**ciphertext 출력으로 변환하는 일련의 알고리즘. 평문을 암호문으로 변환하는 것이 **암호화**encryption, 암호문을 평문으로 변환하는 것이 **복호화**decryption. 

암호 시스템은 **키**key를 사용하여 암호화 알고리즘을 보조. 

**대칭 키**symmetric key **암호 시스템**은 암호화 및 복호화에 같은 키를 사용. 하지만 네트워크를 통해 한 쪽에서 다른 쪽으로 키를 전송할 때 제3자가 가로챌 위험이 있음. 이러한 키 분배 문제를 해결하기 위해 공개 키 암호 시스템이 개발됨.

#### 공개 키 암호 시스템

**공개 키 암호 시스템**은 암호화 및 복호화에 서로 다른 키를 사용. 암호화에 사용하는 키를 **공개 키**public key, 복호화에 사용하는 키를 **비밀 키**secret key라고 함. 

#### 해싱 vs 암호화

암호화는 복호화를 전제로 하는 '양방향 과정'. 

반면 해싱은 데이터를 입력하면 고정 길이의 출력을 생성하며, 이후에는 원래 데이터를 필요로 하지 않는 '단방향 과정'. 

### 컴퓨터 보안에서 해시의 역할
컴퓨터 보안에서 해시는 디지털 서명이나 사용자 인증 등 여러 가지 용도로 사용됨.

디지털 서명은 디지털 데이터의 유효성을 검증하는 데 사용됨. 즉, 수신된 데이터가 누구에게서 왔는지를 확인하는 방법. 이를 위해 데이터는 개인키(?) 소유자의 서명을 포함해야 함.

일반적인 디지털 서명 방식으로는 **RSA**Revest-Shamir-Adleman와 **DSA**digital signiture algorithm가 있고 두 방식 모두 디지털 서명의 보안을 위해 해시를 사용. DSA 방식에서는 **SHA**(secure hash algorithm) **기반의 암호화 해시 함수**를 사용.

사용자 인증 시 해시를 사용하면 비밀번호 보안이 강화됨. 데이터베이스에 비빌번호가 평문 그대로 저장돼 있다면 DB 노출 시 모든 비밀번호를 볼 수 있음.

해시를 사용해 비밀번호를 보관하면 (사용자가 비밀번호를 생성한 시점부터) DB에 저장되는 것은 평문 그대로가 아닌 해시값이기 때문에 비밀번호 자체는 노출되지 않음. 

이외에도 난수 생성, 메시지 인증 코드(message authentication code, MAC), 단방향 함수 등에 해시를 사용

### 해시와 순환 중복 검사
**순환 중복 검사**cyclic redundancy check, CRC는 디지털 데이터의 오류를 감지하는 방식으로, 해시 함수의 원리를 이용해 데이터의 유효성을 검증함. 

(원리설명은 너무 간략해 이해가 어려우므로 생략)

수신 데이터의 CRC가 발신 데이터의 CRC와 일치하지 않는다면 데이터가 손상됐을 가능성이 큼. 프로그래머는 해당 데이터를 무시하거나 발신자가 데이터를 재전송하도록 설계할 수 있음.

#### 해시의 다른 용도
검색엔진, 컴파일러, 데이터베이스 등 많은 양의 복잡한 검색 연산을 수행해야 하는 경우 링크드 리스트 같은 일반적인 데이터 구조로는 부족. 해시 테이블의 시간 복잡도는 O(1)이므로 이처럼 복잡한 검색 연산을 수행하는 곳에 유용. 


## 5 그래프

### 차원, 점 선

### 그래프

### 그래프 vs 트리

### 무향 그래프와 유향 그래프

### 가중치 그래프

### 그래프와 소셜 네트워크 서비스

### 그래프 데이터베이스


# Part 2 알고리즘

## 6 선형 및 이진 탐색

### 선형 탐색

#### 선형성

#### 선형 탐색의 원리
배열에서 요소를 순서대로 비교하여 숫자 7을 찾는 알고리즘을 생각해보자.

1. 숫자 7을 저장할 변수를 마련한다.
2. 배열 탐색을 시작한다.
3. 배열의 각 요소를 숫자 7이 저장된 변수와 비교한다.
4. 변수와 배열의 요소가 일치하면 숫자를 찾은 것이다.
5. 찾은 숫자의 인덱스를 반환한다.

이처럼 요소를 순서대로 비교한다면 1\~1억까지의 데이터 중 1억을 찾는 경우 최대1억 번을 비교해야 할 것이다. 이러한 유형의 알고리즘을 **선형 알고리즘**linear algorithm이라고 한다. 선형 알고리즘의 실행 시간은 요소 개수에 비례해 증가하므로 시간 복잡도는 O(*n*)이다. 

선형 탐색은 숫자뿐만 아니라 이름, 이미지, 오디오 등 모든 유형의 데이터에 적용할 수 있으나 비효율적인 것이 단점. 

### 이진 탐색

#### 로그

#### 이진 탐색의 원리
**이진 탐색**binary search으로 1~9의 숫자로 이뤄진 배열에서 숫자 6을 찾는 예시

배열의 중간(길이가 짝수라면 n/2번째) 요소를 기준으로 삼는다. 기준이 찾으려는 값보다 작으면 그 이하 요소들을 삭제, 크면 그 이상인 요소들을 삭제한다. 목표하는 값을 찾을 때까지 반복한다.

먼저 가운데 요소인 5와 6(찾는 값)을 비교. 6보다 작으므로 1\~5까지 삭제. 남은 건 6\~9. 다음 가운데 요소인 7과 6을 비교. 6보다 크므로 7\~9를 삭제. 남은 건 6. 6과 찾으려는 값이 같으므로 6의 인덱스를 반환한다. 

이진 탐색은 중간 요소와 찾으려는 값을 비교할 때마다 탐색 범위가 1/2로 줄어든다. 정렬된 데이터 수를 n, 비교 횟수를 m이라고 하면 다음 식이 성립

n x (1/2)<sup>m</sup> = 1

n = 2<sup>m</sup>

m = log<sub>2</sub>n

따라서 이진 탐색의 시간 복잡도는 O(log*n*). O(*n*)인 선형 탐색보다 훨씬 효율적이다. 간단한 탐색을 수행할 때는 선형 탐색에 비해 단위 속도의 향상이 미미하지만 복잡한 탐색을 수행할 땐 큰 폭으로 향상된다.

주의할 점은 이진 탐색은 배열이 정렬된 상태에서만 올바로 동작한다는 것. 


## 7 정렬 알고리즘

### 정렬 알고리즘의 특징

### 버블 정렬

### 선택 정렬

### 삽입 정렬

### 셀 정렬

### 병합 정렬

### 퀵 정렬

### 힙 정렬

### 버킷 정렬

### 기수 정렬


## 8 경로 탐색 알고리즘

### 너비 우선 탐색

### 깊이 우선 탐색

### 데이크스트라 알고리즘

### A+ 알고리즘


## 9 군집화 알고리즘

### K-평균 알고리즘

### K-최근접 이웃 알고리즘

### 머신러닝

### 신경망

### 딥러닝


# Part 3 데이터 구조와 알고리즘을 이해하는 데 필요한 지식들

## 10 무작위성

### 무작위

### 하드웨어 이해하기

#### 회로와 트랜지스터

#### 증폭기, 피드백, 클럭, 오실레이터

#### 논리 게이트

#### 조합 및 순차 논리

#### 혼성 신호 회로, 유도 저항, 노이즈

### 유사 난수

#### 선형 피드백 시프트 레지스터

### 참난수 생성기


## 11 스케줄링 알고리즘

### 운영체제

#### 범용 운영체제

#### 실시간 운영체제

### 인터럽트와 인터럽트 서비스 루틴

### 유한 상태 기계

### 커널, 프로세스, 스레드, 작업

### 메모리 관리 장치

### 작업 제어 블록

### 스케줄러와 스케줄링

#### 선착순 스케줄링

#### 최단 작업 우선 스케줄링

#### 우선순위 스케줄링

#### 라운드 로빈 스케줄링

#### 다단계 큐 스케줄링과 다단계 피드


## 12 알고리즘 기획과 설계

### 타당한 기획과 설계의 필요성

### 순서도

#### 순서도 기호

#### 흐름선

#### 단말 기호

#### 입출력 기호

#### 처리 기호

#### 판단 기호

#### 종속 처리 기호

### 프로그램 구조

#### 순차 구조

#### if-then 구조

#### if-then-else 구조

#### while 반복 구조

#### do-while 반복 구조

#### switch-case 구조

#### 선형 탐색 알고리즘의 순서도

### 유사 코드


### 부록, 더 나아가기
